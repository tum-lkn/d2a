"""
Module that implements configuration functionality for the OpenNetVM and
MoonGen based measurements.
"""
from typing import List, Any, Tuple, Dict
import os
import numpy as np

SID_OFFSET = 2


def get_template_run():
    """
        Create a run without commands, SFCs and weights with a test duration
        of five seconds and a rate of 10 GBit/s with 64 byte packets.
    """
    return Run(
        worker_commands=[],
        sfcs=[],
        weights=[],
        test_duration=10,
        rate=int(3.5e6), # packets per second for 10 GBit/s
        experiment_name='TemplateRun',
        packet_size=64,
        bit_s=1904000000
    )


class Run(object):
    """
        Represents the setting for one measurement setting. This
        includes the configured SFCs, the traffic that is send,
        the fraction each SFC gets, etc.
    """
    def __init__(self, worker_commands: List[str], sfcs: List[List[Any]],
                 weights: List[float], test_duration: int, rate: int, experiment_name: str,
                 mode=None, run_manager_cmd=None, path_to_result_folder=None,
                 path_to_nf_control_plane=None, path_to_test_data=None,
                 packet_size=64, bit_s=None, num_tx_threads=1, with_yielding=True,
                 with_rate_cost=False, with_backpressure=False, bs_thresh=0.997,
                 sched_latency_ns=24000000):
        """
            Args:
                worker_cmds: List of strings that start VNFs.
                sfcs: List of list of ints representing the SFCs. The
                    ints index into the worker_cmds argument.
                weights: List of floats with the same length as sfcs.
                    Gives the percentage of traffic that is send to
                    each sfc.
                test_duration: Duration of the run, i.e., how long
                    MoonGen will measure throughput and latency.
                rate: The rate in Mbit/s that is generated by MoonGen.
                    Each SFC gets corresponding fractions of this rate
                    as input.
                name: The identifier of this run.
                mode: The mode that is used. Currently not used.
                packet_size: Size of packets in byte.
                bit_s: Rate in megabype per second in case rate is set in
                    pps.
                num_tx_threads: Number of TX threads.
                with_yielding: True if yielding should be used.
                with_rate_cost: True if rate cost proportional fairness is used.
                with_backpressure: True if backpressure should be used.
                bs_thresh: Float speciyfing the number of packets that must be
                    received to consider a rate as fulfilled.
        """
        assert type(test_duration) is int, "test_duration is not an int"
        assert type(rate) is int, "rate is not an int"
        assert len(weights) == len(sfcs), "Number of weights and sfcs must be the same"
        assert test_duration > 3

        if path_to_result_folder is None:
            self.path_to_result_folder = "/home/nfv/TestResults/"
        else:
            self.path_to_result_folder = path_to_result_folder

        if path_to_nf_control_plane is None:
            self.path_to_nf_control_plane = "/home/nfv/NFControlPlane/"
        else:
            self.path_to_nf_control_plane = path_to_nf_control_plane

        if path_to_test_data is None:
            self.path_to_test_data = "/home/nfv/TestData/Archive/"
        else:
            self.path_to_test_data = path_to_test_data

        # self._run_manager_cmd = "sudo /home/nfv/nvf-scheduling/onvm/onvm_mgr/" +\
        #     "x86_64-native-linuxapp-gcc/onvm_mgr -l 0,1,2 -n 8 " +\
        #     "--proc-type=primary -- -p 3 -n 0xff -s stdout -v 1 -e 4"
        self.num_tx_threads = num_tx_threads
        self.with_yielding = with_yielding
        self.with_backpressure = with_backpressure
        self.with_rate_cost = with_rate_cost
        self.worker_commands = worker_commands
        self._sfcs = sfcs
        self.weights = weights
        self.test_duration = int(test_duration)
        self.bit_s = rate if bit_s is None else bit_s
        # self._rate = rate
        self.experiment_name = experiment_name
        self.mode = mode
        self._packet_size = packet_size
        self.bs_thresh = bs_thresh
        # self._set_mbits()
        self._sched_latency_ns = sched_latency_ns
        self.sched_min_granularity_ns = int(self.sched_latency_ns / 10.)

    @property
    def sched_latency_ns(self):
        return self._sched_latency_ns

    @sched_latency_ns.setter
    def sched_latency_ns(self, value):
        assert type(value) == int
        self._sched_latency_ns = value
        self.sched_min_granularity_ns = int(self._sched_latency_ns / 10.)

    @property
    def run_manager_cmd(self):
        """
            Build the run manager cmd from the passed arguments.
        """
        run_manager_cmd = "sudo /home/nfv/nvf-scheduling/onvm/onvm_mgr/" +\
            "x86_64-native-linuxapp-gcc/onvm_mgr -l 0,1,{tx_cores:s} -n 8 " +\
            "--proc-type=primary -- -p 3 -n 0xff -s stdout -v 1 -e {features:d}"
        features = int(self.with_rate_cost) + int(self.with_backpressure) * 2 +\
            int(self.with_yielding) * 4
        cores = ",".join(
            ["{:d}".format(i) for i in range(2, self.num_tx_threads + 2)]
        )
        return run_manager_cmd.format(
            tx_cores=cores,
            features=features
        )

    @property
    def sfcs(self) -> List[List[int]]:
        return self._sfcs

    @sfcs.setter
    def sfcs(self, sfcs: List[List[int]]):
        self._sfcs = sfcs
        # self._set_mbits()

    @property
    def rate(self) -> int:
        """
        Rate in PPS.
        """
        return int(1000000 * self.bit_s / (self.packet_size * 8))

    # @rate.setter
    # def rate(self, rate:int):
    #     self._rate = rate
    #     self._set_mbits()

    @property
    def packet_size(self) -> int:
        return self._packet_size

    @packet_size.setter
    def packet_size(self, packet_size: int):
        self._packet_size = packet_size
        # self._set_mbits()

    def _set_mbits(self):
        """
            Calculate rate as packets-per-second times packet size, convert to bit
            and then to Mbit. Then subtract the rate that is added by the latency
            measurement. Currently, rate of latency packets is set to one packet
            per SFC every ten miliseconds.
        """
        self.bit_s = self.rate * self.packet_size * 8 / 2**20
        assert self.bit_s < 9537, "Calculated rate is {}".format(self.bit_s)
        self.bit_s = int(self.bit_s - len(self.sfcs) * 84 * 8 * 10 / 2**20)

    @classmethod
    def from_dict(cls, d: dict) -> "Run":
        return cls(**d)

    @classmethod
    def from_run(cls, run: "Run") -> "Run":
        return cls(**run.to_dict())

    def to_dict(self) -> dict:
        # Cast all int based stuff to int type. Numpy ints cannot be serialized
        # to json.
        if type(self.weights) == np.ndarray:
            weights = self.weigths.tolist()
        else:
            weights = self.weights
        weights = [float(w) for w in weights]

        sfcs = []
        for sfc in self.sfcs:
            tmp = []
            for vnf in sfc:
                tmp.append(int(vnf))
            sfcs.append(tmp)
        return {
            "worker_commands": self.worker_commands,
            "sfcs": sfcs,
            "weights": weights,
            "test_duration": int(self.test_duration),
            "rate": int(self.rate),
            "experiment_name": self.experiment_name,
            "mode": self.mode,
            "run_manager_cmd": self.run_manager_cmd,
            "path_to_result_folder": self.path_to_result_folder,
            "path_to_nf_control_plane": self.path_to_nf_control_plane,
            "path_to_test_data": self.path_to_test_data,
            "packet_size": int(self.packet_size),
            "bit_s": int(self.bit_s),
            "num_tx_threads": self.num_tx_threads,
            "with_yielding": self.with_yielding,
            "with_backpressure": self.with_backpressure,
            "with_rate_cost": self.with_rate_cost,
            "bs_thresh": self.bs_thresh,
            "sched_latency_ns": self.sched_latency_ns
        }


def _get_sfc_start_sids(sfcs: List[List], max_length=None) -> list:
    """
    Given a list of lists representing SFCs, i.e., each list in sfcs represents
    a VNF belonging to this SFC, calculates the service id of each of the
    SFCs that corresponds to the first VNF in this SFC.

    Args:
        sfcs: List of lists representing SFCs.
        max_length: Maximum SFC length. If not passed calculate from SFCs.

    Returns:
        sids: List of ints. Each entry is a service id of a VNF starting a SFC.
    """
    if max_length is None:
        max_length = np.max([len(sfc) for sfc in sfcs])
    sids = [i * max_length + 2 for i in range(len(sfcs))]
    return sids


def to_moongen_cmd(run_config: Run) -> str:
    """
        Given a Run object return a cmd string to start the MoonGen script that
        measures throughput and latency of the system.
        Args:
            run_config: Configuration for this run.
        Returns:
            cmd: command line argument that starts a MoonGen script based on the
                passed run configuration.
        Example:
            Returned cmd string has the format:
                sudo <path-to-moongen> <path-to-script> <txPort> <rxPort>
                    <int>(:<int>)* <float>(:<float>)* <int> <int>
            The arguments are:
                1. Path to the moongen executable.
                2. Path to the lua script.
                3. The port over which packets are send.
                4. The port on which packets are received.
                5. A colon separated list of OpenNetVM service ids.
                6. A colong separated list of fractions of traffic that should
                    be send to each service id.
                7. The total rate that is send into the system in packets per second.
                8. The measurement duration in seconds (note that this is not the
                   duration of a complete run. There is static overhead. This is
                   only the duration during which samples are gathered that are
                   later reported back.)
    """
    path_to_moongen = "/home/nfv/MoonGen/build/MoonGen"
    path_to_script = "/home/nfv/git-repos/nfv-benchmark/scripts/load.lua"
    tx_dev = 1
    rx_dev = 0

    sids_str = ":".join(["{:d}".format(sid) for sid
                         in _get_sfc_start_sids(run_config.sfcs, run_config.max_num_vnfs_per_sfc)])
    weigth_str = ":".join(["{:f}".format(w) for w in run_config.weights])

    cmd = "sudo {:s} {:s} {:d} {:d} {:s} {:s} {:.5f} {:d} -s {:d}".format(
        path_to_moongen,
        path_to_script,
        tx_dev,
        rx_dev,
        sids_str,
        weigth_str,
        run_config.bit_s / 1e6,
        int(run_config.test_duration),
        int(run_config.packet_size)
    )
    print(cmd)
    return cmd

def get_moongen_cmd(weights: List[float], first_ids: List[int], rate_in_pps: float, duration: int, packet_size: int):
    path_to_moongen = "/home/nfv/MoonGen/build/MoonGen"
    path_to_script = "/home/nfv/git-repos/nfv-benchmark/scripts/load.lua"
    tx_dev = 0
    rx_dev = 1

    sids_str = ":".join(["{:d}".format(sid) for sid in first_ids])
    weigth_str = ":".join(["{:f}".format(w) for w in weights])

    cmd = "sudo {:s} {:s} {:d} {:d} {:s} {:s} {:.5f} {:d} -s {:d}".format(
        path_to_moongen,
        path_to_script,
        tx_dev,
        rx_dev,
        sids_str,
        weigth_str,
        (rate_in_pps * packet_size * 8) / 1e6,
        duration,
        packet_size
    )
    return cmd



def get_available_cycles() -> Tuple[Dict[int, int], Dict[int, int]]:
    """
    Returns two mappings: From t-argument to cycles and from cycles to t-argument.
    """
    def _piecewise(a, b, vals):
      for i in range(1, b - a):
          vals[a + i] = int((vals[b] - vals[a]) / (b - a) * i + vals[a])
    t_c = {
        #0: 80,
        #10: 189,
        #20: 242,
        #30: 252,
        #40: 450,
        #50: 479,
        #60: 595,
        #70: 568,
        #80: 654,
        #90: 742,
        #100: 883,
        #110: 888,
        #120: 973,
        #130: 1079,
        #140: 1391,
        #150: 1407,
        #160: 1495,
        #170: 1585,
        #180: 1782,
        #190: 1733,
        #200: 1818,
        #210: 1916,
        #220: 2034,
        #230: 1933,
        #240: 2020,
        #250: 2136,
        #260: 2481,
        #270: 2366,
        #280: 2457,
        #290: 2566,
        #300: 2408,
        #310: 2529,
        #320: 2572,
        #330: 2669,
        #340: 2749,
        #350: 2900,
        #360: 2893,
        #370: 2987,
        #380: 3073,
        #390: 3296,
        #400: 3217,
        #410: 3313,
        #420: 3423,
        #430: 3776,
        #440: 3738,
        #450: 3847,
        #460: 3937,
        #470: 4151,
        #480: 4053,
        #490: 4174,
        #500: 4282,
        #510: 4433,
        #520: 4261,
        #530: 4354,
        #540: 4501,
        #550: 4773,
        #560: 4698,
        #570: 4810,
        #580: 4931,
        #590: 4730,
        #600: 4836,
        #610: 4887,
        #620: 4983,
        #630: 5077,
        #640: 5213,
        #650: 5229,
        #660: 5308,
        #670: 5404,
        #680: 5521,
        #690: 5530,
        #700: 5630,
        #710: 5731,
        #720: 6087,
        #730: 6056,
        #740: 6168,
        #750: 6256,
        #760: 6458,
        #770: 6512,
        #780: 6481,
        #790: 6574,
        #800: 6727,
        #810: 6580,
        #820: 6699,
        #830: 6805,
        #840: 7115,
        #850: 6998,
        #860: 7124,
        #870: 7217,
        #880: 7047,
        #890: 7156,
        #900: 7209,
        #910: 7297,
        #920: 7312,
        #930: 7532,
        #940: 7529,
        #950: 7614,
        #960: 7699,
        #970: 7848,
        #980: 7849,
        #990: 7938,
        #1000: 8027,
        #1010: 8395,
        #1020: 8360,
        #1030: 8580,
        #1040: 8565,
        #1050: 8810,
        #1060: 8677,
        #1070: 8767,
        #1080: 8876,
        #1090: 9079,
        #1100: 9139,
        #1110: 8997,
        #1120: 9095,
        #1130: 9459,
        #1140: 9411,
        #1150: 9416,
        #1160: 9551
        # New Data
	    0: 175,
	    10: 240,
	    20: 306,
	    30: 371,
        40: 436,
        50: 501,
        60: 567,
        70: 632,
        80: 697,
        90: 762,
        100: 828,
        110: 893,
        120: 958,
        130: 1023,
        140: 1089,
        150: 1154,
        160: 1219,
        170: 1284,
        180: 1350,
        190: 1415,
        200: 1480,
        210: 1545,
        220: 1611,
        230: 1676,
        240: 1741,
        250: 1806,
        260: 1872,
        270: 1937,
        280: 2002,
        290: 2067,
        300: 2132,
        310: 2198,
        320: 2263,
        330: 2328,
        340: 2393,
        350: 2459,
        360: 2524,
        370: 2589,
        380: 2654,
        390: 2720,
        400: 2785,
        410: 2850,
        420: 2915,
        430: 2981,
        440: 3046,
        450: 3111,
        460: 3176,
        470: 3242,
        480: 3307,
        490: 3372,
        500: 3437,
        510: 3503,
        520: 3568,
        530: 3633,
        540: 3698,
        550: 3764,
        560: 3829,
        570: 3894,
        580: 3959,
        590: 4025,
        600: 4090,
        610: 4155,
        620: 4220,
        630: 4286,
        640: 4351,
        650: 4416,
        660: 4481,
        670: 4547,
        680: 4612,
        690: 4677,
        700: 4742,
        710: 4808,
        720: 4873,
        730: 4938,
        740: 5003,
        750: 5069,
        760: 5134,
        770: 5199,
        780: 5264,
        790: 5329,
        800: 5395,
        810: 5460,
        820: 5525,
        830: 5590,
        840: 5656,
        850: 5721,
        860: 5786,
        870: 5851,
        880: 5917,
        890: 5982,
        900: 6047,
        910: 6112,
        920: 6178,
        930: 6243,
        940: 6308,
        950: 6373,
        960: 6439,
        970: 6504,
        980: 6569,
        990: 6634,
        1000: 6700,
        1010: 6765,
        1020: 6830,
        1030: 6895,
        1040: 6961,
        1050: 7026,
        1060: 7091,
        1070: 7156,
        1080: 7222,
        1090: 7287,
        1100: 7352,
        1110: 7417,
        1120: 7483,
        1130: 7548,
        1140: 7613,
        1150: 7678,
        1160: 7744
    }
    keys = list(t_c.keys())
    keys.sort()
    for k1, k2 in zip(keys[:-1], keys[1:]):
        _piecewise(k1, k2, t_c)
    # _piecewise(4, 10, t_c)
    # _piecewise(10, 20, t_c)
    # _piecewise(20, 30, t_c)
    # _piecewise(30, 40, t_c)
    c_t = {v: k for k, v in t_c.items()}
    return t_c, c_t


class GetMaxT(object):
    def __init__(self):
        t_c, _ = get_available_cycles()
        self.t_c = t_c

    def __call__(self, rate: int, capacity: int) -> int:
        """
        Get the maximum possible t for the given rate that can still sustain this
        rate if the core is dedicated.

        Args:
            rate: Rate that should be supported in packets per second.
            capacity: Capacity of the machine in cycles.
        """
        max_t = 1
        for t, c in self.t_c.items():
            if 0.8 * capacity / c > rate and t > max_t:
                max_t = t
            else:
                continue
        return max_t


class ToWorkerCmd(object):
    def __init__(self):
        t_c, c_t = get_available_cycles()
        self.t_arg_to_cycles = t_c
        self.cycles_to_t_arg = c_t
        self.template_chain = '/bin/bash -c "./go.sh {sid:d} -d {nsid:d} -t '+\
            '{t_arg:d} -c {core:d}"'
        self.template_out = '/bin/bash -c "./go.sh {sid:d} -r 1 -t '+\
            '{t_arg:d} -c {core:d}"'

    def __call__(self, vnf, sid: int, next_sid: int, placement: dict) -> str:
        """
        Create a worker cmd string.

        Args:
            vnf: A Job object for which worker command should be generated.
            sid: Service ID of job object.
            next_sid: Service ID of next job in chain.
            placement: Mapping from Job objects to Machine objects.

        Returns:
            Command string for worker.
        """
        if next_sid == 'out':
            return self.template_out.format(
                sid=sid,
                t_arg=self.cycles_to_t_arg[vnf.vnf.compute_per_packet],
                core=placement[vnf].physical_id
            )
        else:
            return self.template_chain.format(
                sid=sid,
                nsid=next_sid,
                t_arg=self.cycles_to_t_arg[vnf.vnf.compute_per_packet],
                core=placement[vnf].physical_id
            )


def get_worker_commands(sfcs: List[Any], placement: dict, max_length=None) -> List[str]:
    """
        Gets as input a list of Sfc objects and a placement, i.e., mapping of Job
        to Machine objects, and returns a list of worker commands.

        Args:
            sfcs: List of Sfc objects.
            placement: VNF to core assignment
            max_length: Integer specifying the maximum SFC length. Defaults to the
                length of the longest SFC.

        Returns:
            commands: List of worker commands to start VNFs.
    """
    to_worker_cmd = ToWorkerCmd()
    if max_length is None:
        max_length = np.max([len(sfc.jobs) for sfc in sfcs])
    commands = []
    for i, sfc in enumerate(sfcs):
        for k, job in enumerate(sfc.jobs):
            sid = i * max_length + k + 2
            if k == len(sfc.jobs) - 1:
                n_sid = 'out'
            else:
                n_sid = sid + 1
            commands.append(to_worker_cmd(
                vnf=job,
                sid=sid,
                next_sid=n_sid,
                placement=placement
            ))
    return commands


def _make_tx_iid_assignment_ll(sfcs: List[Any], max_length=None) -> Dict[int, List[int]]:
    num_tx_threads = 5
    if max_length is None:
        max_length = np.max([len(sfc.jobs) for sfc in sfcs])
    assignment = {i: [] for i in range(num_tx_threads)}
    load = [0 for i in range(num_tx_threads - 1)]
    assignment[0].append(1)

    iid = 2
    for sfc in sfcs:
        for j in range(len(sfc.jobs)):
            thread = np.argmin(load)
            assignment[thread + 1].append(iid)
            load[thread] += sfc.weight
            iid += 1
    return assignment


def _make_tx_iid_assignment_rr(sfcs: List[Any], max_length=None) -> Dict[int, List[int]]:
    num_tx_threads = 5
    if max_length is None:
        max_length = np.max([len(sfc.jobs) for sfc in sfcs])
    assignment = {i: [] for i in range(num_tx_threads)}
    assignment[0].append(1)

    iid = 2
    for sfc in sfcs:
        for j in range(len(sfc.jobs)):
            thread = (iid - 2) % (num_tx_threads - 1) + 1
            assignment[thread].append(iid)
            iid += 1
    return assignment


def _make_tx_iid_assignment(sfcs: List[Any], max_length=None) -> Dict[int, List[int]]:
    num_tx_threads = 5
    if max_length is None:
        max_length = np.max([len(sfc.jobs) for sfc in sfcs])
    assignment = {i: [] for i in range(num_tx_threads)}
    assignment[0].append(1)

    iid = 2
    for sfc in sfcs:
        for j in range(len(sfc.jobs)):
            if j < 2:
                assignment[1].append(iid)
            elif 2 <= j <= 3:
                assignment[2].append(iid)
            elif 4 <= j <= 5:
                assignment[3].append(iid)
            elif 6 <= j <= 8:
                assignment[4].append(iid)
            iid += 1
    return assignment


def make_tx_iid_config_files(sfcs: List[Any], max_length=None) -> None:
    path = os.path.join('/home', 'nfv', 'NFControlPlane', 'tx-thread-{:d}-instances.csv')
    assignment = _make_tx_iid_assignment_rr(sfcs, max_length)
    for k, iids in assignment.items():
        with open(path.format(k), "w") as fh:
            print("{} -> {}".format(k, ','.join(['{:d}'.format(iid) for iid in iids])))
            fh.write(','.join(['{:d}'.format(iid) for iid in iids]))


def get_sfc_sid_list(sfcs: List[Any], max_length=None) -> List[List[int]]:
    """
        To start OpenNetVm the sfcs have to be converted into a list of list
        of ints, where each int corresponds to the service id of that VNF.
        The service IDs must be aligned with the worker commands.

        Args:
            sfcs: List of Sfc objects.
            max_length: Maximum length of SFCs. If None take the maximum length
                of SFCs in argument sfcs.

        Returns:
            sids: List of list of ints, service ids of the individual VNFs.
    """
    if max_length is None:
        max_length = np.max([len(sfc.jobs) for sfc in sfcs])

    sids = []
    for i, sfc in enumerate(sfcs):
        tmp = []
        for j in range(len(sfc.jobs)):
            tmp.append(i * max_length + j + SID_OFFSET)
        sids.append(tmp)
    return sids
